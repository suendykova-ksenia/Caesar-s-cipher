#include <iostream> //стандартная библиотека
#include <string> //для использования строк
#include <windows.h> //для работы с ОС: функции SetConsoleCP(1251) и SetConsoleOutputCP(1251)
#include <fstream> //для ввода в файл
#include <ctime> //библиотека времени

using namespace std;

string time() {
    char str[26];
    time_t result = time(NULL);
    ctime_s(str, sizeof str, &result);
    return str;
} //функция времени

string basprog(int hk) //основная функция шифрования/расшифровки текста
{
    ofstream fout;
    fout.open("LogFile.txt", ios_base::app); //файл для ввода, здесь хранятся вседения об ошибке, не удаляются, а добавляются
    cin.ignore(); //фнкция очищает буфер ввода, и пользователь получает возможность ввести следующую строку
    string s1; //переменная для исходного текста
    getline(cin, s1); //ввод исходного текста (текст считывается полностью, вместе с пробелами)
    int size = s1.length(); //количество символов в исходном тексте
    //cout << size << endl; //для проверки в процессе кодирования
    char* f1 = new char[size]; //динамический массив для хранения символов(в виде букв) исходного текста
    for (int i = 0; i < size; i++) //обращаемся по порядку к символам исходного текста и добавляем их в массив f1
    {
        f1[i] = s1[i];
    }
    cout << endl << "Шаг для кодировки:  ";
    int k; //переменная для шага кодировки
    cin >> k;
p2:
    if (!cin) //если ввели не число и получили ошибку ввода
    {
        k = '*'; //присваиаем k символ *, чтобы не получилось так, что программа при вводе символа (буквы, например) присваивало шагу значение 0 (т.к. fail/FALSE/0 - обозначение ошибки) и затем продолжилось выполнение шифрования/расшифровки якобы с нулевым шагом, хотя должно было вывести сообщение об ошибке и запросить ввод занаво
    }
    if (((cin.fail() == 0) && (k)) || (k == 0)) //поверка на ввод шага кодировки(допустимы только +, - числа и 0)
    {
        bool success = true; // если нет ошибок в входном потоке даём true для стопа цикла
    }
    else { // если есть ошибки
        cout << "ОШИБКА: Введенные данные не соответствуют формату. Осуществите ввод еще раз. " << endl;
        fout << time() << "   ОШИБКА: Введенные данные не соответствуют формату | Строка с ошибкой: " << __LINE__ << endl; //запись строки в файл.
        cin.clear(); //очищает ошибки входного потока для флажка cin.fail
        cin.ignore(cin.rdbuf()->in_avail()); //удаляем символы в буфере
        cout << "Шаг для кодировки:  ";
        cin >> k;
        goto p2; //после повторного ввода значения возвращаемся к проверке
    }
    if (hk == 1) //если шифруем текст, то прибавляем шаг кодировки
    {
        k = k;
    }
    if (hk == 2) //если расшифровывем текст, то вычитаем шаг кодировки
    {
        k = -k;
    }
    int* arr1 = new int[size]; //массив для хранения символов(в виде чисел кода) исходного текста
    int* arr2 = new int[size]; //массив для хранения символов(в виде чисел кода) текста после преобразования
    char* f2 = new char[size]; //массив для хранения символов(в виде букв) текста после преобразования

    for (int i = 0; i < size; i++)
    {
        char b = f1[i]; //переменная - имя для члена массива f1
        char x = f2[i]; //переменная - имя для члена массива f2
        int r = (int)(b); //переменная для хранения кода символа
        arr1[i] = r; //добавляем код символа r в массив arr1 
        //cout << "Символ_1 " << (i + 1) << " соответствует числу " << arr1[i] << endl; //для проверки в процессе кодирования
        if ((r >= -64) && (r <= -33)) //если символ в исходном тексте - буква А-Я
        {
            if (((r + k) >= -64) && ((r + k) <= 90)) //если символ в преобразованном тексте - буква А-Я
            {
                arr2[i] = (r + k); //добавляем код символа после преобразования в массив arr2
            }
            if ((r + k) > -33) //если код символа в преобразованном тексте вышел за рамки букв А-Я справа, то, дойдя до конца, начинаем отсчет смволов снова с А-Б-В-...
            {
                arr2[i] = (r + k - 32);
            }
            if ((r + k) < -64) //если код символа в преоразованном тексте вышел за рамки букв А-Я слева, то, перейдя начало, продолжаем отсчет символов снова с Я-Ю-Э-...
            {
                arr2[i] = (32 + r + k);
            }
        }
        if ((r >= -32) && (r <= -1)) //если символ в исходном тексте - буква а-я
        {
            if (((r + k) >= -32) && ((r + k) <= -1)) //если символ в преобразованном тексте - буква а-я
            {
                arr2[i] = (r + k); //добавляем код символа после преобразования в массив arr2
            }
            if ((r + k) > -1) //если код символа в преобразованном тексте вышел за рамки букв а-я справа, то, дойдя до конца, начинаем отсчет смволов снова с а-б-в-...
            {
                arr2[i] = (r + k - 32);
            }
            if ((r + k) < -32) //если код символа в преоразованном тексте вышел за рамки букв а-я слева, то, перейдя начало, продолжаем отсчет символов снова с я-ю-э-...
            {
                arr2[i] = (32 + r + k);
            }
        }
        if ((r >= 65) && (r <= 90)) //если символ в исходном тексте - буква A-Z
        {
            if (((r + k) >= 65) && ((r + k) <= 90)) //если символ в преобразованном тексте - буква A-Z
            {
                arr2[i] = (r + k); //добавляем код символа после преобразования в массив arr2
            }
            if ((r + k) > 90) //если код символа в преобразованном тексте вышел за рамки букв A-Z справа, то, дойдя до конца, начинаем отсчет смволов снова с A-B-C-...
            {
                arr2[i] = (r + k - 26); //или что то же самое (64+((r + k)-90))
            }
            if ((r + k) < 65) //если код символа в преоразованном тексте вышел за рамки букв A-Z слева, то, перейдя начало, продолжаем отсчет символов снова с Z-Y-X-...
            {
                arr2[i] = (26 + r + k); //или что то же самое (91-65-(r + k))
            }
        }
        if ((r >= 97) && (r <= 122)) //если символ в исходном тексте - буква a-z
        {
            if (((r + k) >= 97) && ((r + k) <= 122)) //если символ в преобразованном тексте - буква a-z
            {
                arr2[i] = (r + k); //добавляем код символа после преобразования в массив arr2
            }
            if ((r + k) > 122) //если код символа в преобразованном тексте вышел за рамки букв a-z справа, то, дойдя до конца, начинаем отсчет смволов снова с a-b-c-...
            {
                arr2[i] = (r + k - 26); //или что то же самое (96+((r + k)-122))
            }
            if ((r + k) < 97) //если код символа в преоразованном тексте вышел за рамки букв a-z слева, то, перейдя начало, продолжаем отсчет символов снова с z-y-x-...
            {
                arr2[i] = (26 + r + k); //или что то же самое (123-97-(r + k))
            }
        }
        if ((r >= 48) && (r <= 57)) //если символ в исходном тексте - цифра 0-9
        {
            if (((r + k) >= 48) && ((r + k) <= 57)) //если символ в преобразованном тексте - цифра 0-9
            {
                arr2[i] = (r + k); //добавляем код символа после преобразования в массив arr2
            }
            if ((r + k) > 57) //если код символа в преобразованном тексте вышел за рамки цифр 0-9 справа, то, дойдя до конца, начинаем отсчет смволов снова с 0-1-2-...
            {
                arr2[i] = (r + k - 10); //или что то же самое (47+((r + k)-57))
            }
            if ((r + k) < 48) //если код символа в преоразованном тексте вышел за рамки цифр 0-9 слева, то, перейдя начало, продолжаем отсчет символов снова с 9-8-7-...
            {
                arr2[i] = (10 + r + k); //или что то же самое (58-48-(r + k))
            }
        }
        if (!((r >= 65) && (r <= 90)) && !((r >= 97) && (r <= 122)) && !((r >= 48) && (r <= 57)) && !((r >= -64) && (r <= -1))) //на случай, если символ в исходном тексте - не бква A-Z, a-z и не цифра 0-9
        {
            arr2[i] = r; //символ неизменным добавляется в массив arr2 (в том числе и пробелы)
        }
        char y = arr2[i]; //перемення для обратного преобразования кода символа в сам символ
        f2[i] = y; //добавляем сам символ после преобразования в массив f2
        //cout << "Символ_2 " << (i + 1) << " соответствует числу " << arr2[i] << endl; //для проверки в процессе кодирования
        //cout << f2[i] << endl; //для проверки в процессе кодирования
    }
    string s2; //переменная для преобразованного текста
    for (int i = 0; i < size; i++) //добавляем преобразованные символы из массива в строку s2(слияние в строку)
    {
        s2 = s2 + f2[i];
    }
    return s2; //по завершении функции возвращаем преобразованный текст в виде строки
}

int main()
{
    setlocale(LC_ALL, "ru");
    SetConsoleCP(1251); //задаем кодировку для вывода символов на экран
    SetConsoleOutputCP(1251); //задаем кодировку для ввода символов с клавиатуры в консоль
    ofstream fout;
    fout.open("LogFile.txt", ios_base::app); //файл для ввода, здесь хранятся вседения об ошибке, не удаляются, а добавляются
    if (!fout.is_open())
    {
        cout << "Не удалось открыть файл для записи ошибок!" << endl;
        return(0);
    }
    else
    {
        fout << time() << "   Программа запущена" << endl; //запись строки в файл
        cout << "Добро пожаловать!" << endl
            << "Введите текст, и программа преобразует его с помощью шифра Цезаря." << endl
            << "Шаг для кодировки определяется пользователем." << endl
            << "Учтите, что в исходном тексте изменятся только буквы латинского, русского алфавита и цифры, остальные символы останутся неизменными." << endl;
    func: //строчка кода, на которую вернемся при вызове goto func
        cout << endl << "Выберете функцию для дальнейшего действия: " << endl
            << "1. Шифрование текста" << endl
            << "2. Расшифровка текста" << endl
            << "3. Что такое \"Шифр Цезаря\"? (справка)" << endl
            << "4. Выйти из программы" << endl;
        cout << "Номер функции: ";
        int h; //перменная для функции
        cin >> h;
    p1:
        if ((h == 1) || (h == 2) || (h == 3) || (h == 4)) //поверка на ввод номера функции(допустимы только значения h=1;2;3;4)
        {
            bool success = true; // если нет ошибок в входном потоке даём true для стопа цикла
        }
        else { // если есть ошибки
            cout << "ОШИБКА: Введенные данные не соответствуют формату. Осуществите ввод еще раз. " << endl;
            fout << time() << "   ОШИБКА: Введенные данные не соответствуют формату | Строка с ошибкой: " << __LINE__ << endl; //запись строки в файл. воспользовалась функцией времени, а так же макросом для вывода номера строки в коде, на которой произошла ошибка ввода
            cin.clear(); //очищает ошибки входного потока для флажка cin.fail
            cin.ignore(cin.rdbuf()->in_avail()); //удаляем символы в буфере
            cout << "Номер функции: ";
            cin >> h;
            goto p1; //после повторного ввода значения возвращаемся к проверке
        }
        if (h == 1) //внутри выполняем стандартные для шифрования шаги
        {
            int hk = 1; //переменная для того, чтобы функция basprog(hk) поняла, что нужно зашифровать текст
            cout << "Введите текст для шифрования: " << endl;
            string s2 = basprog(hk); //вызываем функцию basprog(hk) и присваиваем переменной s2 возвращаем значение этой функции
            cout << endl << "Текст зашифрован: " << endl << s2 << endl; //выводим зашифрованный текст
            goto func; //возвращаемся к списку функций
        }
        if (h == 2) //внутри выполняем стандартные для расшифровки шаги
        {
            int hk = 2; //переменная для того, чтобы функция basprog(hk) поняла, что нужно расшифровать текст
            cout << "Введите текст для расшифровки: " << endl;
            string s2 = basprog(hk); //вызываем функцию basprog(hk) и присваиваем переменной s2 возвращаем значение этой функции
            cout << endl << "Текст расшифрован: " << endl << s2 << endl; //выводим расшифрованный текст
            goto func; //возвращаемся к списку функций
        }
        if (h == 3) //просто выводим справку о шифре Цезаря на экран
        {
            cout << "Шифр Цезаря — это вид шифра подстановки, в котором каждый символ в открытом тексте заменяется символом, находящимся на некотором постоянном числе позиций левее или правее него в алфавите." << endl
                << "Например, в шифре со сдвигом вправо на 3, \"А\" была бы заменена на \"Г\", \"Б\" станет \"Д\", и так далее." << endl
                << "Шифр назван в честь римского полководца Гая Юлия Цезаря, использовавшего его для секретной переписки со своими генералами." << endl
                << "(Википедия)" << endl;
            goto func;
        }
        if (h == 4) //выходим из программы
        {
            cout << "Вы вышли из программы" << endl;
            fout << time() << "   Программа завершена" << endl << endl; //запись строки в файл
            return(0);
        }
        fout.close();
        return 0;
    }
}