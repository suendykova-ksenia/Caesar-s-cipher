#include <iostream> //стандартная библиотека
#include <string> //для использования строк
#include <windows.h> //для работы с ОС: функции SetConsoleCP(1251) и SetConsoleOutputCP(1251)

using namespace std;

string basprog(int hk) //основная функция шифрования/расшифровки текста
{
    cin.ignore(); //фнкция очищает буфер ввода, и пользователь получает возможность ввести следующую строку
    string s1; //переменная для исходного текста
    getline(cin, s1); //ввод исходного текста (текст считывается полностью, вместе с пробелами)
    int size = s1.length(); //количество символов в исходном тексте
    //cout << size << endl; //для проверки в процессе кодирования
    char* f1 = new char[size]; //динамический массив для хранения символов(в виде букв) исходного текста
    for (int i = 0; i < size; i++) //обращаемся по порядку к символам исходного текста и добавляем их в массив f1
    {
        f1[i] = s1[i];
    }
    cout << endl << "Шаг для кодировки:  ";
    int k; //переменная для шага кодировки
    cin >> k;
    if (hk == 1) //если шифруем текст, то прибавляем шаг кодировки
    {
        k = k;
    }
    if (hk == 2) //если расшифровывем текст, то вычитаем шаг кодировки
    {
        k = -k;
    }
    int* arr1 = new int[size]; //массив для хранения символов(в виде чисел кода) исходного текста
    int* arr2 = new int[size]; //массив для хранения символов(в виде чисел кода) текста после преобразования
    char* f2 = new char[size]; //массив для хранения символов(в виде букв) текста после преобразования

    for (int i = 0; i < size; i++)
    {
        char b = f1[i]; //переменная - имя для члена массива f1
        char x = f2[i]; //переменная - имя для члена массива f2
        int r = (int)(b); //переменная для хранения кода символа
        arr1[i] = r; //добавляем код символа r в массив arr1 
        //cout << "Символ_1 " << (i + 1) << " соответствует числу " << arr1[i] << endl; //для проверки в процессе кодирования
        if ((r >= -64) && (r <= -33)) //если символ в исходном тексте - буква А-Я
        {
            if (((r + k) >= -64) && ((r + k) <= 90)) //если символ в преобразованном тексте - буква А-Я
            {
                arr2[i] = (r + k); //добавляем код символа после преобразования в массив arr2
            }
            if ((r + k) > -33) //если код символа в преобразованном тексте вышел за рамки букв А-Я справа, то, дойдя до конца, начинаем отсчет смволов снова с А-Б-В-...
            {
                arr2[i] = (r + k - 32);
            }
            if ((r + k) < -64) //если код символа в преоразованном тексте вышел за рамки букв А-Я слева, то, перейдя начало, продолжаем отсчет символов снова с Я-Ю-Э-...
            {
                arr2[i] = (32 + r + k);
            }
        }
        if ((r >= -32) && (r <= -1)) //если символ в исходном тексте - буква а-я
        {
            if (((r + k) >= -32) && ((r + k) <= -1)) //если символ в преобразованном тексте - буква а-я
            {
                arr2[i] = (r + k); //добавляем код символа после преобразования в массив arr2
            }
            if ((r + k) > -1) //если код символа в преобразованном тексте вышел за рамки букв а-я справа, то, дойдя до конца, начинаем отсчет смволов снова с а-б-в-...
            {
                arr2[i] = (r + k - 32);
            }
            if ((r + k) < -32) //если код символа в преоразованном тексте вышел за рамки букв а-я слева, то, перейдя начало, продолжаем отсчет символов снова с я-ю-э-...
            {
                arr2[i] = (32 + r + k);
            }
        }
        if ((r >= 65) && (r <= 90)) //если символ в исходном тексте - буква A-Z
        {
            if (((r + k) >= 65) && ((r + k) <= 90)) //если символ в преобразованном тексте - буква A-Z
            {
                arr2[i] = (r + k); //добавляем код символа после преобразования в массив arr2
            }
            if ((r + k) > 90) //если код символа в преобразованном тексте вышел за рамки букв A-Z справа, то, дойдя до конца, начинаем отсчет смволов снова с A-B-C-...
            {
                arr2[i] = (r + k - 26); //или что то же самое (64+((r + k)-90))
            }
            if ((r + k) < 65) //если код символа в преоразованном тексте вышел за рамки букв A-Z слева, то, перейдя начало, продолжаем отсчет символов снова с Z-Y-X-...
            {
                arr2[i] = (26 + r + k); //или что то же самое (91-65-(r + k))
            }
        }
        if ((r >= 97) && (r <= 122)) //если символ в исходном тексте - буква a-z
        {
            if (((r + k) >= 97) && ((r + k) <= 122)) //если символ в преобразованном тексте - буква a-z
            {
                arr2[i] = (r + k); //добавляем код символа после преобразования в массив arr2
            }
            if ((r + k) > 122) //если код символа в преобразованном тексте вышел за рамки букв a-z справа, то, дойдя до конца, начинаем отсчет смволов снова с a-b-c-...
            {
                arr2[i] = (r + k - 26); //или что то же самое (96+((r + k)-122))
            }
            if ((r + k) < 97) //если код символа в преоразованном тексте вышел за рамки букв a-z слева, то, перейдя начало, продолжаем отсчет символов снова с z-y-x-...
            {
                arr2[i] = (26 + r + k); //или что то же самое (123-97-(r + k))
            }
        }
        if ((r >= 48) && (r <= 57)) //если символ в исходном тексте - цифра 0-9
        {
            if (((r + k) >= 48) && ((r + k) <= 57)) //если символ в преобразованном тексте - цифра 0-9
            {
                arr2[i] = (r + k); //добавляем код символа после преобразования в массив arr2
            }
            if ((r + k) > 57) //если код символа в преобразованном тексте вышел за рамки цифр 0-9 справа, то, дойдя до конца, начинаем отсчет смволов снова с 0-1-2-...
            {
                arr2[i] = (r + k - 10); //или что то же самое (47+((r + k)-57))
            }
            if ((r + k) < 48) //если код символа в преоразованном тексте вышел за рамки цифр 0-9 слева, то, перейдя начало, продолжаем отсчет символов снова с 9-8-7-...
            {
                arr2[i] = (10 + r + k); //или что то же самое (58-48-(r + k))
            }
        }
        if (!((r >= 65) && (r <= 90)) && !((r >= 97) && (r <= 122)) && !((r >= 48) && (r <= 57)) && !((r >= -64) && (r <= -1))) //на случай, если символ в исходном тексте - не бква A-Z, a-z и не цифра 0-9
        {
            arr2[i] = r; //символ неизменным добавляется в массив arr2 (в том числе и пробелы)
        }
        char y = arr2[i]; //перемення для обратного преобразования кода символа в сам символ
        f2[i] = y; //добавляем сам символ после преобразования в массив f2
        //cout << "Символ_2 " << (i + 1) << " соответствует числу " << arr2[i] << endl; //для проверки в процессе кодирования
        //cout << f2[i] << endl; //для проверки в процессе кодирования
    }
    string s2; //переменная для преобразованного текста
    for (int i = 0; i < size; i++) //добавляем преобразованные символы из массива в строку s2(слияние в строку)
    {
        s2 = s2 + f2[i];
    }
    return s2; //по завершении функции возвращаем преобразованный текст в виде строки
}

int main()
{
    SetConsoleCP(1251); //задаем кодировку для вывода символов на экран
    SetConsoleOutputCP(1251); //задаем кодировку для ввода символов с клавиатуры в консоль
    setlocale(LC_ALL, "ru");
    
    cout << "Добро пожаловать!" << endl 
        << "Введите текст, и программа преобразует его с помощью шифра Цезаря." << endl
        << "Шаг для кодировки определяется пользователем." << endl
        << "Учтите, что в исходном тексте изменятся только буквы латинского, русского алфавита и цифры, остальные символы останутся неизменными." << endl;
    func: //строчка кода, на которуювернемся при вызове goto func
    cout << endl << "Выберете функцию для дальнейшего действия: " << endl
        << "1. Шифрование текста" << endl
        << "2. Расшифровка текста" << endl
        << "3. Что такое \"Шифр Цезаря\"? (справка)" << endl
        << "4. Выйти из программы" << endl;
    int h; //перменная для функции
    cin >> h;
    if (h == 1) //внутри выполняем стандартные для шифрования шаги
    {
        int hk = 1; //переменная для того, чтобы функция basprog(hk) поняла, что нужно зашифровать текст
        cout << "Введите текст для шифрования: " << endl;
        string s2 = basprog(hk); //вызываем функцию basprog(hk) и присваиваем переменной s2 возвращаем значение этой функции
        cout << endl << "Текст зашифрован: " << endl << s2 << endl; //выводим зашифрованный текст
        goto func; //возвращаемся к списку функций
    }
    if (h == 2) //внутри выполняем стандартные для расшифровки шаги
    {
        int hk = 2; //переменная для того, чтобы функция basprog(hk) поняла, что нужно расшифровать текст
        cout << "Введите текст для расшифровки: " << endl;
        string s2 = basprog(hk); //вызываем функцию basprog(hk) и присваиваем переменной s2 возвращаем значение этой функции
        cout << endl << "Текст расшифрован: " << endl << s2 << endl; //выводим расшифрованный текст
        goto func; //возвращаемся к списку функций
    }
    if (h == 3) //просто выводим справку о шифре Цезаря на экран
    {
        cout << "Шифр Цезаря — это вид шифра подстановки, в котором каждый символ в открытом тексте заменяется символом, находящимся на некотором постоянном числе позиций левее или правее него в алфавите." << endl
            << "Например, в шифре со сдвигом вправо на 3, \"А\" была бы заменена на \"Г\", \"Б\" станет \"Д\", и так далее." << endl
            << "Шифр назван в честь римского полководца Гая Юлия Цезаря, использовавшего его для секретной переписки со своими генералами." << endl
            << "(Википедия)" << endl;
        goto func;
    }
     if (h == 4) //выходим из программы
    {
         cout << "Вы вышли из программы" << endl;
         return(0);
    }
    return 0;
}
